import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ChevronLeft, ChevronRight, Lightbulb, Calculator, BookOpen, Info, RefreshCw, Download, Loader2, AlertTriangle } from 'lucide-react';
import { jsPDF } from 'jspdf';
import { MindMapData, Language, DetailedSummary } from '../types.ts';
import { translations } from '../utils/translations.ts';
import { generateDetailedSummary } from '../services/gemini.ts';


const downloadSummaryPdf = (mindMapData: MindMapData, summaryData: DetailedSummary, language: Language) => {
  const doc = new jsPDF({
    orientation: 'p',
    unit: 'mm',
    format: 'a4'
  });
  const isRtl = language === 'ar';
  const t = translations[language].viewer;

  // IMPORTANT: Default jsPDF fonts do not support Arabic characters.
  // A production solution would require fetching and embedding a font like Noto Sans Arabic.
  doc.setFont('Helvetica');

  const pageHeight = doc.internal.pageSize.height;
  const pageWidth = doc.internal.pageSize.width;
  let y = 20;
  const margin = 15;
  const maxWidth = pageWidth - margin * 2;

  const checkPageBreak = (spaceNeeded: number) => {
    if (y + spaceNeeded > pageHeight - margin) {
      doc.addPage();
      y = margin;
    }
  };
  
  const writeText = (text: string | string[], x: number, yPos: number, options: any = {}) => {
      const align = isRtl ? 'right' : 'left';
      const finalX = isRtl ? pageWidth - x : x;
      doc.text(text, finalX, yPos, { ...options, align, lang: language });
  }

  // Title
  doc.setFontSize(20);
  doc.setFont(undefined, 'bold');
  const titleLines = doc.splitTextToSize(mindMapData.mainTopic, maxWidth);
  writeText(titleLines, margin, y);
  y += (titleLines.length * 8) + 10;
  
  doc.setDrawColor(220, 220, 220);
  doc.line(margin, y, pageWidth - margin, y);
  y += 10;

  // Introduction
  doc.setFontSize(16);
  doc.setFont(undefined, 'bold');
  checkPageBreak(15);
  writeText(t.introduction, margin, y);
  y += 8;
  doc.setFontSize(11);
  doc.setFont(undefined, 'normal');
  const introLines = doc.splitTextToSize(summaryData.introduction, maxWidth);
  checkPageBreak(introLines.length * 5);
  writeText(introLines, margin, y);
  y += introLines.length * 5 + 10;

  // Sections
  summaryData.sections.forEach(section => {
    checkPageBreak(20);
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    const sectionTitleLines = doc.splitTextToSize(section.title, maxWidth);
    writeText(sectionTitleLines, margin, y);
    y += (sectionTitleLines.length * 6) + 4;
    
    doc.setFontSize(11);
    doc.setFont(undefined, 'normal');
    const contentLines = doc.splitTextToSize(section.content, maxWidth);
    checkPageBreak(contentLines.length * 5);
    writeText(contentLines, margin, y);
    y += contentLines.length * 5 + 10;
  });
  
  // Conclusion
  checkPageBreak(20);
  doc.setFontSize(16);
  doc.setFont(undefined, 'bold');
  writeText(t.conclusion, margin, y);
  y += 8;
  doc.setFontSize(11);
  doc.setFont(undefined, 'normal');
  const conclusionLines = doc.splitTextToSize(summaryData.conclusion, maxWidth);
  checkPageBreak(conclusionLines.length * 5);
  writeText(conclusionLines, margin, y);

  // Footer with page numbers
  const pageCount = doc.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor(150);
    doc.text(`Page ${i} of ${pageCount} - Generated by Nodqra`, pageWidth / 2, pageHeight - 10, { align: 'center' });
  }

  doc.save(`${mindMapData.mainTopic.replace(/ /g, '_')}_summary.pdf`);
};

interface SlideViewerProps {
  data: MindMapData;
  onReset: () => void;
  language: Language;
}

const SlideViewer: React.FC<SlideViewerProps> = ({ data, onReset, language }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [direction, setDirection] = useState(0);
  const [isGeneratingPdf, setIsGeneratingPdf] = useState(false);
  const [pdfError, setPdfError] = useState<string | null>(null);

  const t = translations[language].viewer;
  const nodes = data.nodes;

  const slideVariants = {
    enter: (direction: number) => ({ x: direction > 0 ? '100%' : '-100%', opacity: 0, scale: 0.9 }),
    center: { zIndex: 1, x: 0, opacity: 1, scale: 1 },
    exit: (direction: number) => ({ zIndex: 0, x: direction < 0 ? '100%' : '-100%', opacity: 0, scale: 0.9 })
  };

  const swipeConfidenceThreshold = 10000;
  const swipePower = (offset: number, velocity: number) => Math.abs(offset) * velocity;

  const paginate = (newDirection: number) => {
    if (currentIndex + newDirection < 0 || currentIndex + newDirection >= nodes.length) return;
    setDirection(newDirection);
    setCurrentIndex(currentIndex + newDirection);
  };

  const getIcon = (type: string) => {
    switch (type) {
      case 'formula': return <Calculator className="h-8 w-8 text-blue-500" />;
      case 'fact': return <Info className="h-8 w-8 text-green-500" />;
      case 'example': return <BookOpen className="h-8 w-8 text-purple-500" />;
      default: return <Lightbulb className="h-8 w-8 text-yellow-500" />;
    }
  };
  
  const handleDownloadPdf = async () => {
    setIsGeneratingPdf(true);
    setPdfError(null);
    try {
        const summaryData = await generateDetailedSummary(data, language);
        downloadSummaryPdf(data, summaryData, language);
    } catch (error) {
        console.error("Failed to generate or download PDF:", error);
        setPdfError(t.pdfError);
    } finally {
        setIsGeneratingPdf(false);
    }
  };

  const progress = ((currentIndex + 1) / nodes.length) * 100;

  return (
    <div className="w-full max-w-4xl mx-auto py-8 px-4" dir={language === 'ar' ? 'rtl' : 'ltr'}>
      <div className="flex flex-col sm:flex-row justify-between items-start mb-6 gap-4">
        <div>
          <h2 className="text-3xl font-extrabold text-dark max-w-xl">{data.mainTopic}</h2>
          <p className="text-gray-500 mt-1">{t.slide} {currentIndex + 1} {t.of} {nodes.length}</p>
        </div>
        <div className="flex items-center gap-4 flex-shrink-0 self-end sm:self-auto">
          <button 
            onClick={onReset}
            className="flex items-center gap-2 text-sm font-medium text-gray-500 hover:text-primary transition-colors"
          >
            <RefreshCw className="h-4 w-4" />
            {t.new}
          </button>
          <button 
            onClick={handleDownloadPdf}
            disabled={isGeneratingPdf}
            className="flex items-center justify-center gap-2 text-sm font-semibold text-white bg-secondary hover:bg-secondary-dark disabled:bg-secondary/50 disabled:cursor-wait transition-colors px-4 py-2 rounded-lg shadow-md shadow-secondary/20 transform hover:scale-105"
            aria-label={isGeneratingPdf ? t.generatingPDF : t.downloadSummary}
          >
            {isGeneratingPdf ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Download className="h-4 w-4" />
            )}
            <span className="hidden sm:inline">{isGeneratingPdf ? t.generatingPDF : t.downloadSummary}</span>
          </button>
        </div>
      </div>
      
      {pdfError && (
          <motion.div 
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="mb-4 p-3 bg-red-50 border border-red-200 text-red-700 rounded-lg flex items-center gap-2 text-sm"
          >
              <AlertTriangle className="h-5 w-5 flex-shrink-0" />
              <span>{pdfError}</span>
          </motion.div>
      )}

      <div className="w-full bg-gray-200 h-2 rounded-full mb-8 overflow-hidden">
        <motion.div 
          className="bg-gradient-to-r from-primary-light to-primary h-full" 
          initial={{ width: 0 }}
          animate={{ width: `${progress}%` }}
          transition={{ duration: 0.5, ease: "easeInOut" }}
        />
      </div>

      <div className="relative h-[480px] w-full flex items-center justify-center overflow-hidden" dir="ltr">
        <AnimatePresence initial={false} custom={direction} mode="popLayout">
          <motion.div
            key={currentIndex}
            custom={direction}
            variants={slideVariants}
            initial="enter"
            animate="center"
            exit="exit"
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
            drag="x"
            dragConstraints={{ left: 0, right: 0 }}
            dragElastic={0.2}
            onDragEnd={(e, { offset, velocity }) => {
              const swipe = swipePower(offset.x, velocity.x);
              if (swipe < -swipeConfidenceThreshold) paginate(1);
              else if (swipe > swipeConfidenceThreshold) paginate(-1);
            }}
            className="absolute w-full h-full max-w-lg bg-white rounded-2xl shadow-2xl border border-gray-100 flex flex-col"
            dir={language === 'ar' ? 'rtl' : 'ltr'}
          >
            <div className="flex-1 p-8 flex flex-col">
              <div className="flex items-center justify-between mb-6">
                <span className="bg-gray-100 text-primary-dark px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider">
                  {nodes[currentIndex].iconType}
                </span>
                {getIcon(nodes[currentIndex].iconType)}
              </div>

              <h3 className="text-2xl font-bold text-dark mb-4 leading-tight">
                {nodes[currentIndex].title}
              </h3>
              
              <blockquote className="text-gray-600 mb-6 leading-relaxed italic border-s-4 border-primary/20 ps-4">
                {nodes[currentIndex].summary}
              </blockquote>

              <div className="mt-auto bg-gray-50/80 rounded-xl p-5 border border-gray-100">
                <h4 className="text-sm font-bold text-dark uppercase mb-3">{t.keyPoints}</h4>
                <ul className="space-y-3">
                  {nodes[currentIndex].keyPoints.map((point, idx) => (
                    <li key={idx} className="flex items-start gap-3 text-gray-700 text-sm">
                      <span className="block w-1.5 h-1.5 bg-primary rounded-full mt-1.5 flex-shrink-0" />
                      {point}
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          </motion.div>
        </AnimatePresence>
      </div>

      <div className="flex justify-center items-center gap-8 mt-8" dir="ltr">
        <button 
          onClick={() => paginate(-1)}
          disabled={currentIndex === 0}
          className="p-4 rounded-full bg-white border border-gray-200 shadow-md hover:bg-gray-50 disabled:opacity-40 disabled:cursor-not-allowed transition-all text-gray-700 transform hover:scale-105"
          aria-label="Previous slide"
        >
          <ChevronLeft className="h-6 w-6" />
        </button>
        <span className="text-sm font-medium text-gray-400 select-none">{t.swipe}</span>
        <button 
          onClick={() => paginate(1)}
          disabled={currentIndex === nodes.length - 1}
          className="p-4 rounded-full bg-white border border-gray-200 shadow-md hover:bg-gray-50 disabled:opacity-40 disabled:cursor-not-allowed transition-all text-gray-700 transform hover:scale-105"
          aria-label="Next slide"
        >
          <ChevronRight className="h-6 w-6" />
        </button>
      </div>
    </div>
  );
};

export default SlideViewer;